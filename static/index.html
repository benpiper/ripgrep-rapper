<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ripgrep Rapper</title>
    <link rel="stylesheet" href="/static/style.css">
</head>

<body>
    <div class="container">
        <header>
            <h1 class="graffiti-text">RIPGREP RAPPER</h1>
            <p class="subtitle">Spit hot fire locally. Search your flows.</p>
        </header>

        <section class="control-panel">
            <div class="input-group">
                <label for="search-path">THE HOOD (Search Path)</label>
                <div class="path-input-row">
                    <input type="text" id="search-path" placeholder="." value="." required>
                    <button id="scope-btn" class="scope-btn" onclick="scopePath()">SCOPE IT</button>
                </div>
                <div id="path-info" class="path-info"></div>
            </div>

            <div id="query-container">
                <div class="query-row">
                    <div class="input-group">
                        <label>FREESTYLE (Query)</label>
                        <input type="text" class="query-input" placeholder="Drop the phone #, email, or name..."
                            required>
                    </div>
                    <div class="input-group">
                        <label>FLOW TYPE</label>
                        <select class="type-select">
                            <option value="generic">Generic</option>
                            <option value="name">Name</option>
                            <option value="phone">Phone Number (Digits)</option>
                            <option value="email">Email</option>
                        </select>
                    </div>
                    <button class="remove-btn" onclick="removeRow(this)" style="display:none;">X</button>
                </div>
            </div>

            <button id="add-query-btn" class="secondary-btn">+ Add Another Flow</button>

            <div class="settings-row">
                <div class="input-group">
                    <label for="context">BARS (Context lines)</label>
                    <input type="number" id="context" value="5" min="1" max="20">
                </div>
                <div class="input-group checkbox-group">
                    <input type="checkbox" id="fold" checked>
                    <label for="fold">FOLD LONG RHYMES</label>
                </div>
            </div>

            <button id="search-btn" class="mic-check-btn">MIC CHECK (Search)</button>
        </section>

        <section id="results" class="results-area">
            <div class="results-header">
                <div id="status-msg" class="status-msg">Ready to drop the beat...</div>
                <button id="export-btn" class="export-btn" style="display:none;" onclick="exportResults()">EXPORT
                    RESULTS</button>
            </div>
            <div id="command-executed" class="command-box"></div>
            <div id="variations-used" class="variations-list"></div>
            <div id="matches-container" class="matches-container"></div>
        </section>
    </div>

    <script>
        // Auto-scope on load
        window.addEventListener('DOMContentLoaded', () => scopePath());

        async function scopePath() {
            const searchPath = document.getElementById('search-path').value;
            const infoDiv = document.getElementById('path-info');
            const scopeBtn = document.getElementById('scope-btn');

            scopeBtn.disabled = true;
            scopeBtn.textContent = '...';
            infoDiv.textContent = 'Scoping...';
            infoDiv.className = 'path-info';

            try {
                const resp = await fetch('/search/pathinfo', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ search_path: searchPath })
                });

                if (!resp.ok) {
                    const err = await resp.json();
                    infoDiv.textContent = err.detail || 'Invalid path';
                    infoDiv.classList.add('path-error');
                    return;
                }

                const data = await resp.json();
                const sizeMB = (data.total_size_bytes / (1024 * 1024)).toFixed(2);
                const sizeGB = (data.total_size_bytes / (1024 * 1024 * 1024)).toFixed(2);
                const sizeStr = data.total_size_bytes > 1024 * 1024 * 1024 ? `${sizeGB} GB` : `${sizeMB} MB`;

                let timeStr;
                if (data.est_search_seconds < 0.01) {
                    timeStr = '< 1ms';
                } else if (data.est_search_seconds < 1) {
                    timeStr = `~${Math.round(data.est_search_seconds * 1000)}ms`;
                } else {
                    timeStr = `~${data.est_search_seconds.toFixed(1)}s`;
                }

                infoDiv.innerHTML = `<span class="path-resolved">${data.resolved_path}</span> ` +
                    `<span class="path-stats">${data.file_count} files &bull; ${sizeStr} &bull; Est. ${timeStr} @ 10k RPM</span>`;
            } catch (e) {
                infoDiv.textContent = 'Error: ' + e.message;
                infoDiv.classList.add('path-error');
            } finally {
                scopeBtn.disabled = false;
                scopeBtn.textContent = 'SCOPE IT';
            }
        }

        document.getElementById('search-path').addEventListener('change', () => scopePath());

        document.getElementById('add-query-btn').addEventListener('click', () => {
            const container = document.getElementById('query-container');
            const firstRow = container.querySelector('.query-row');
            const newRow = firstRow.cloneNode(true);

            // Clear input
            newRow.querySelector('.query-input').value = '';
            // Show remove button
            newRow.querySelector('.remove-btn').style.display = 'inline-block';

            container.appendChild(newRow);
            updateRemoveButtons();
        });

        function removeRow(btn) {
            btn.closest('.query-row').remove();
            updateRemoveButtons();
        }

        function updateRemoveButtons() {
            const rows = document.querySelectorAll('.query-row');
            const removeBtns = document.querySelectorAll('.remove-btn');
            if (rows.length === 1) {
                removeBtns.forEach(b => b.style.display = 'none');
            } else {
                removeBtns.forEach(b => b.style.display = 'inline-block');
            }
        }

        document.getElementById('search-btn').addEventListener('click', async () => {
            const searchBtn = document.getElementById('search-btn');
            const searchPath = document.getElementById('search-path').value;
            const context = parseInt(document.getElementById('context').value);
            const fold = document.getElementById('fold').checked;

            const queries = [];
            document.querySelectorAll('.query-row').forEach(row => {
                const q = row.querySelector('.query-input').value;
                const t = row.querySelector('.type-select').value;
                if (q.trim()) {
                    queries.push({ query: q, type: t });
                }
            });

            const resultsDiv = document.getElementById('matches-container');
            const statusDiv = document.getElementById('status-msg');
            const variationsDiv = document.getElementById('variations-used');
            const commandDiv = document.getElementById('command-executed');

            if (queries.length === 0) {
                statusDiv.textContent = "You need to spit some bars first! (Enter a query)";
                return;
            }

            // Disable button and show loading state
            searchBtn.disabled = true;
            searchBtn.textContent = 'SEARCHING...';
            searchBtn.classList.add('loading');

            statusDiv.textContent = "Dropping the beat...";
            resultsDiv.innerHTML = '';
            variationsDiv.textContent = '';
            commandDiv.textContent = '';
            document.getElementById('export-btn').style.display = 'none';

            const requestBody = JSON.stringify({ queries: queries, search_path: searchPath, context, fold });

            // State for incremental rendering
            let lastFilePath = null;
            let lastLineNum = -1;
            let matchesCount = 0;
            let allMatches = [];  // For export
            let streamData = {};  // Will hold preview/done info

            try {
                const response = await fetch('/search/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: requestBody
                });

                if (!response.ok) {
                    throw new Error("Search failed");
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); // Keep incomplete last line in buffer

                    for (const line of lines) {
                        if (!line.trim()) continue;
                        let event;
                        try { event = JSON.parse(line); } catch { continue; }

                        if (event.event === 'preview') {
                            commandDiv.textContent = `$ ${event.command_executed}`;
                            variationsDiv.textContent = `Variations used: ${JSON.stringify(event.variations)}`;
                            streamData = event;
                            statusDiv.textContent = "Scanning...";
                        } else if (event.event === 'match' || event.event === 'context') {
                            // Track for export
                            allMatches.push(event);

                            // File header
                            if (event.file_path !== lastFilePath) {
                                const hdr = document.createElement('div');
                                hdr.className = 'file-header';
                                hdr.textContent = event.file_path;
                                resultsDiv.appendChild(hdr);
                                lastFilePath = event.file_path;
                                lastLineNum = -1;
                            }

                            // Gap separator
                            if (lastLineNum !== -1 && event.line_number > lastLineNum + 1) {
                                const sep = document.createElement('div');
                                sep.className = 'separator';
                                sep.textContent = '--- Scratch ---';
                                resultsDiv.appendChild(sep);
                            }

                            // Result line
                            const div = document.createElement('div');
                            div.className = event.is_match ? 'line match' : 'line context';
                            div.innerHTML = `<span class="line-num">${event.line_number}</span> <span class="content">${escapeHtml(event.content)}</span>`;
                            resultsDiv.appendChild(div);
                            lastLineNum = event.line_number;

                            if (event.is_match) {
                                matchesCount = event.count;
                                statusDiv.textContent = `${matchesCount} matches found...`;
                            }
                        } else if (event.event === 'done') {
                            matchesCount = event.total_matches;
                            streamData.total_matches = matchesCount;
                            streamData.original_query = event.original_query;
                        }
                    }
                }

                statusDiv.textContent = `Dropped ${matchesCount} matches`;

                if (matchesCount === 0) {
                    resultsDiv.innerHTML = '<div class="no-matches">No bars found for this flow.</div>';
                } else {
                    // Store results for export
                    window._lastSearchData = {
                        total_matches: matchesCount,
                        original_query: streamData.original_query || '',
                        command_executed: streamData.command_executed || '',
                        variations: streamData.variations || [],
                        matches: allMatches,
                    };
                    document.getElementById('export-btn').style.display = 'inline-block';
                }

            } catch (error) {
                statusDiv.textContent = "Production Error: " + error.message;
            } finally {
                searchBtn.disabled = false;
                searchBtn.textContent = 'MIC CHECK (Search)';
                searchBtn.classList.remove('loading');
            }
        });

        function escapeHtml(text) {
            return text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function exportResults() {
            const data = window._lastSearchData;
            if (!data) return;

            let lines = [];
            lines.push('RIPGREP RAPPER - Search Results');
            lines.push('='.repeat(40));
            lines.push(`Query: ${data.original_query}`);
            lines.push(`Command: ${data.command_executed}`);
            lines.push(`Variations: ${JSON.stringify(data.variations)}`);
            lines.push(`Total Matches: ${data.total_matches}`);
            lines.push('');

            let lastFilePath = null;
            let lastLineNum = -1;

            data.matches.forEach(match => {
                if (match.file_path !== lastFilePath) {
                    lines.push('');
                    lines.push(`--- ${match.file_path} ---`);
                    lastFilePath = match.file_path;
                    lastLineNum = -1;
                }

                if (lastLineNum !== -1 && match.line_number > lastLineNum + 1) {
                    lines.push('  ...');
                }

                const marker = match.is_match ? '>>>' : '   ';
                lines.push(`${marker} ${String(match.line_number).padStart(5)}: ${match.content}`);
                lastLineNum = match.line_number;
            });

            const blob = new Blob([lines.join('\n')], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            a.download = `rg-results-${timestamp}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>

</html>